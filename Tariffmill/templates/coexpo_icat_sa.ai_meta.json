{
  "provider": "Anthropic",
  "model": "claude-sonnet-4-20250514",
  "conversation_history": [
    {
      "role": "user",
      "content": "using the file in the path below, the template code here is not extracting the invoice data correctly. please review \n\"C:\\Users\\hpayne\\Downloads\\PACKING LIST FAME1064-FAME1065-FAME1066-FAME1067-MEDLINE25-262.pdf\"\n\n[PDF text extracted automatically - 1 file(s)]"
    },
    {
      "role": "assistant",
      "content": "Looking at the extracted text, I can see this is a **packing list**, not an invoice. The current template is designed to process invoices with pricing information, but this document only contains quantity and style information without unit prices or totals.\n\nThe main issues are:\n\n1. **Document type detection**: The template should recognize this is a packing list and handle it appropriately\n2. **Missing pricing data**: Packing lists don't have unit prices, totals, or invoice numbers in the same format as invoices\n3. **Different data structure**: The line format is `STYLE CUT UNITS DOZENS CASES BUNDLES PRODUCER`\n\nHere's the modified template that can handle both invoices and packing lists:\n\n```python\n\"\"\"\nICAT S.A. DE C.V. Template\n\nTemplate for processing invoices and packing lists from ICAT S.A. DE C.V. (El Salvador)\nfor Co-Expo Ltd shipments.\n\nDocument formats: \n- Multi-page customs invoices with line item tables\n- Multi-page packing lists with quantity information\n\"\"\"\n\nimport re\nfrom typing import List, Dict\nfrom .base_template import BaseTemplate\n\n\nclass CoexpoIcatSaTemplate(BaseTemplate):\n    \"\"\"Template for ICAT S.A. DE C.V. invoices and packing lists.\"\"\"\n\n    name = \"ICAT S.A. DE C.V.\"\n    description = \"Invoices and packing lists from ICAT S.A. DE C.V. (El Salvador) for Co-Expo Ltd\"\n    client = \"Co-Expo\"\n    version = \"2.2.0\"\n    enabled = True\n\n    extra_columns = ['invoice_number', 'po_number', 'cut_number', 'unit_price', 'description', 'country_origin', 'producer', 'weight', 'raw_part_number', 'quantity_unit']\n\n    # Keywords to identify this supplier\n    SUPPLIER_KEYWORDS = [\n        \"icat s.a. de c.v.\",\n        \"km 12 1/2 carretera troncal del norte\",\n        \"frente a pericentro apopa\",\n        \"complejo industrial insinca\",\n        \"co - expo ltd\",\n        \"co-expo ltd\",\n        \"seaboard marine ltd\",\n        \"santo tomas de castilla gt\",\n        \"vidales larra\u00f1aga\"\n    ]\n\n    def can_process(self, text: str) -> bool:\n        \"\"\"Check if this is a ICAT S.A. DE C.V. document.\"\"\"\n        text_lower = text.lower()\n        match_count = 0\n        for keyword in self.SUPPLIER_KEYWORDS:\n            if keyword in text_lower:\n                match_count += 1\n        # Require at least 2 keyword matches for higher confidence\n        return match_count >= 2\n\n    def get_confidence_score(self, text: str) -> float:\n        \"\"\"Return confidence score for template matching.\"\"\"\n        if not self.can_process(text):\n            return 0.0\n\n        text_lower = text.lower()\n        match_count = sum(1 for kw in self.SUPPLIER_KEYWORDS if kw in text_lower)\n\n        # Higher score for more matches - ICAT documents should have many keyword hits\n        if match_count >= 5:\n            return 0.98\n        elif match_count >= 4:\n            return 0.95\n        elif match_count >= 3:\n            return 0.92\n        elif match_count >= 2:\n            return 0.88\n        return 0.80\n\n    def extract_invoice_number(self, text: str) -> str:\n        \"\"\"Extract invoice number from SHIPPER'S REF. NO. section or from invoice references.\"\"\"\n        patterns = [\n            r\"INV\\.\\s*(\\d+[A-Z]*)\",\n            r\"SHIPPER'S REF\\.?\\s*NO\\.?\\s*(?:.*?)INV\\.\\s*(\\d+[A-Z]*)\",\n            r\"INV\\.\\s+(\\d{5}[A-Z]?)\",\n            r\"INV\\.\\s*(\\d+[A-Z]*[A-Z])\",  # For formats like INV. 00823B\n        ]\n\n        # Find all invoice numbers and return the first one\n        for pattern in patterns:\n            matches = re.findall(pattern, text, re.IGNORECASE)\n            if matches:\n                return matches[0].strip()\n\n        # For packing lists, try to extract shipment number\n        shipment_match = re.search(r\"SHIPMENT:\\s*([\\w-]+)\", text, re.IGNORECASE)\n        if shipment_match:\n            return f\"SHIPMENT-{shipment_match.group(1)}\"\n\n        return \"UNKNOWN\"\n\n    def extract_all_invoice_numbers(self, text: str) -> List[str]:\n        \"\"\"Extract all invoice numbers from the document.\"\"\"\n        pattern = r\"INV\\.\\s*(\\d+[A-Z]*)\"\n        matches = re.findall(pattern, text, re.IGNORECASE)\n        \n        # If no invoice numbers found, try shipment number\n        if not matches:\n            shipment_match = re.search(r\"SHIPMENT:\\s*([\\w-]+)\", text, re.IGNORECASE)\n            if shipment_match:\n                return [f\"SHIPMENT-{shipment_match.group(1)}\"]\n        \n        return list(set(matches)) if matches else []\n\n    def extract_project_number(self, text: str) -> str:\n        \"\"\"Extract WK project number or shipment number.\"\"\"\n        patterns = [\n            r\"(WK\\d+-[A-Z0-9-]+)\",\n            r\"WK(\\d+[-\\w]+)\",\n            r\"SHIPMENT:\\s*([\\w-]+)\",\n        ]\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                if 'SHIPMENT' in pattern:\n                    return f\"SHIPMENT-{match.group(1)}\"\n                result = match.group(1) if match.group(1).startswith('WK') else f\"WK{match.group(1)}\"\n                return result\n        return \"UNKNOWN\"\n\n    def extract_manufacturer_name(self, text: str) -> str:\n        \"\"\"Return the manufacturer name.\"\"\"\n        return \"ICAT S.A. DE C.V.\"\n\n    def get_quantity_unit(self, part_number: str, description: str = \"\") -> str:\n        \"\"\"Determine the quantity unit based on part number prefix or description.\n\n        Footwear items (14xx, 15xx prefixes) use PRS (pairs)\n        Apparel items use DOZ (dozens)\n\n        Args:\n            part_number: The part/style number (base or concatenated)\n            description: Optional description text for additional detection\n\n        Returns:\n            'PRS' for footwear, 'DOZ' for apparel (matching TariffMill unit codes)\n        \"\"\"\n        # Check if part number starts with footwear prefixes (14 or 15)\n        part_upper = part_number.upper().strip()\n        if part_upper.startswith('14') or part_upper.startswith('15'):\n            return 'PRS'\n\n        # Also check description for footwear keywords\n        if description:\n            desc_lower = description.lower()\n            if any(kw in desc_lower for kw in ['footwear', 'boot', 'shoe', 'sandal']):\n                return 'PRS'\n\n        # Default to dozens for apparel\n        return 'DOZ'\n\n    def extract_base_style(self, concatenated_style: str) -> str:\n        \"\"\"Extract base style number from concatenated style-cut format.\n\n        Concatenated format: 13C33070HERR01VS1100WHTI\n        Base style format:   13C3-3070\n\n        Pattern breakdown:\n        - 2 digits (category): 13, 14, 15, 12, 10, 11, SK\n        - 1-2 letters (type): C, L, F, S, B, H, PA, TP, HD, etc.\n        - 1 digit (variant): 1, 2, 3, 4, etc.\n        - 4 digits (style number): 3070, 3301, 7254, etc.\n        - Remaining: cut/color/size variation (HERR01VS1100WHTI)\n\n        Examples:\n        - 13C33070HERR01VS1100WHTI -> 13C3-3070\n        - 14S13301TAFF01CN0000WHTI -> 14S1-3301\n        - 12L27254BEM001CC0000ROYI -> 12L2-7254\n        - SK01YLC -> SK01YLC (already short format, no change)\n        - 12F2-3165 -> 12F2-3165 (already has hyphen)\n        \"\"\"\n        style = concatenated_style.strip()\n\n        # If already has hyphen in the right place, return as-is\n        if '-' in style and len(style) <= 12:\n            return style\n\n        # If it's a short SK-style code, return as-is\n        if style.startswith('SK') and len(style) <= 8:\n            return style\n\n        # Try to extract base style from concatenated format\n        # Pattern: (2 digits)(1-2 letters)(1 digit)(4 chars)(rest)\n        # Examples: 13C3-3070, 14S1-3301, 12L2-7254, 13PA-6462, 12L1-54FC, 14P7-301G\n\n        # First try 2-letter type codes with alphanumeric style (BC, LS, etc.)\n        # e.g., 12BC10HSLAB01CC -> 12BC-10HS\n        match = re.match(\n            r'^(\\d{2})([A-Z]{2})[-]?(\\d{2}[A-Z]{2})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 12\n            type_code = match.group(2)   # BC\n            style_num = match.group(3)   # 10HS\n            return f\"{prefix}{type_code}-{style_num}\"\n\n        # Try 2-letter type codes with 4-digit style (PA, TP, HD, CV, FA, SV, EQ, HU, BZ, HY, HZ)\n        match = re.match(\n            r'^(\\d{2})([A-Z]{2})[-]?(\\d{4})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 13, 12, etc.\n            type_code = match.group(2)   # PA, TP, HD, etc.\n            style_num = match.group(3)   # 6462, 7158, etc.\n            return f\"{prefix}{type_code}-{style_num}\"\n\n        # Try 1-letter type codes with alphanumeric style (4 chars: digits + letters)\n        # e.g., 12L154FCEKC601WK -> 12L1-54FC, 14P7301GTAFF01VS -> 14P7-301G\n        match = re.match(\n            r'^(\\d{2})([A-Z])(\\d)(\\d{2}[A-Z]{2}|\\d{3}[A-Z])',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 12, 14, etc.\n            type_code = match.group(2)   # L, P, etc.\n            variant = match.group(3)     # 1, 7, etc.\n            style_num = match.group(4)   # 54FC, 301G, etc.\n            return f\"{prefix}{type_code}{variant}-{style_num}\"\n\n        # Then try 1-letter type codes with 4-digit style (C, L, F, S, B, H, M)\n        match = re.match(\n            r'^(\\d{2})([A-Z])(\\d)(\\d{4})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 13, 14, 12, etc.\n            type_code = match.group(2)   # C, L, F, S, etc.\n            variant = match.group(3)     # 1, 2, 3, etc.\n            style_num = match.group(4)   # 3070, 3301, etc.\n            return f\"{prefix}{type_code}{variant}-{style_num}\"\n\n        # If no match, return original\n        return style\n\n    def is_packing_list(self, text: str) -> bool:\n        \"\"\"Check if document is a packing list.\"\"\"\n        text_lower = text.lower()\n        # Look for packing list indicators\n        if 'packing list' in text_lower:\n            return True\n        # Look for structure typical of packing lists (has STYLE CUT UNITS DOZENS CASES columns)\n        if all(keyword in text_lower for keyword in ['style', 'cut', 'units', 'dozens', 'cases']):\n            return True\n        return False\n\n    def extract_line_items(self, text: str) -> List[Dict]:\n        \"\"\"Extract line items from document (invoice or packing list).\"\"\"\n        if self.is_packing_list(text):\n            return self._extract_packing_list_items(text)\n        else:\n            return self._extract_invoice_items(text)\n\n    def _extract_packing_list_items(self, text: str) -> List[Dict]:\n        \"\"\"Extract line items from packing list format.\n        \n        Packing list format:\n        STYLE CUT UNITS DOZENS CASES BUNDLES PRODUCER NAME ADDRESS\n        WEL19183C 4139 400.00 33.33 2 ICAT S.A DE C.V KM 12 1/2 CTRA...\n        \"\"\"\n        items = []\n        lines = text.split('\\n')\n        \n        # Extract document reference\n        doc_ref = self.extract_invoice_number(text)\n        project_ref = self.extract_project_number(text)\n        \n        # Pattern for packing list lines\n        # Style, Cut, Units (quantity), Dozens, Cases, Bundles, Producer info\n        packing_pattern = re.compile(\n            r'^([A-Z0-9][A-Z0-9-]{3,})\\s+'     # STYLE (like WEL19183C, F28-A03C, etc.)\n            r'(\\d+[-\\d]*)\\s+'                  # CUT (like 4139, 4224-26, etc.)\n            r'([\\d,]+\\.?\\d*)\\s+'               # UNITS (quantity like 400.00)\n            r'([\\d,]+\\.?\\d*)\\s+'               # DOZENS (like 33.33)\n            r'(\\d+)\\s+'                        # CASES (like 2)\n            r'(?:(\\d+)\\s+)?'                   # BUNDLES (optional, sometimes missing)\n            r'((?:ICAT|VIDALES)[^0-9]*)',      # PRODUCER (ICAT or VIDALES followed by address)\n            re.IGNORECASE\n        )\n\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n\n            # Skip header lines\n            if any(skip in line.upper() for skip in ['STYLE CUT UNITS', 'QUANTITY', 'PACKING LIST', 'CUSTOMER', 'CARRIER']):\n                continue\n                \n            # Skip total lines\n            if line.upper().startswith('TOTAL') or 'BOXES TOTAL' in line.upper():\n                continue\n\n            # Try to match packing list pattern\n            match = packing_pattern.match(line)\n            if match:\n                try:\n                    raw_style = match.group(1).strip()\n                    cut ="
    },
    {
      "role": "user",
      "content": "update the selected template code with changes"
    },
    {
      "role": "assistant",
      "content": "```python\n\"\"\"\nICAT S.A. DE C.V. Template\n\nTemplate for processing invoices and packing lists from ICAT S.A. DE C.V. (El Salvador)\nfor Co-Expo Ltd shipments.\n\nDocument formats: \n- Multi-page customs invoices with line item tables\n- Multi-page packing lists with quantity information\n\"\"\"\n\nimport re\nfrom typing import List, Dict\nfrom .base_template import BaseTemplate\n\n\nclass CoexpoIcatSaTemplate(BaseTemplate):\n    \"\"\"Template for ICAT S.A. DE C.V. invoices and packing lists.\"\"\"\n\n    name = \"ICAT S.A. DE C.V.\"\n    description = \"Invoices and packing lists from ICAT S.A. DE C.V. (El Salvador) for Co-Expo Ltd\"\n    client = \"Co-Expo\"\n    version = \"2.2.0\"\n    enabled = True\n\n    extra_columns = ['invoice_number', 'po_number', 'cut_number', 'unit_price', 'description', 'country_origin', 'producer', 'weight', 'raw_part_number', 'quantity_unit']\n\n    # Keywords to identify this supplier\n    SUPPLIER_KEYWORDS = [\n        \"icat s.a. de c.v.\",\n        \"km 12 1/2 carretera troncal del norte\",\n        \"frente a pericentro apopa\",\n        \"complejo industrial insinca\",\n        \"co - expo ltd\",\n        \"co-expo ltd\",\n        \"seaboard marine ltd\",\n        \"santo tomas de castilla gt\",\n        \"vidales larra\u00f1aga\"\n    ]\n\n    def can_process(self, text: str) -> bool:\n        \"\"\"Check if this is a ICAT S.A. DE C.V. document.\"\"\"\n        text_lower = text.lower()\n        match_count = 0\n        for keyword in self.SUPPLIER_KEYWORDS:\n            if keyword in text_lower:\n                match_count += 1\n        # Require at least 2 keyword matches for higher confidence\n        return match_count >= 2\n\n    def get_confidence_score(self, text: str) -> float:\n        \"\"\"Return confidence score for template matching.\"\"\"\n        if not self.can_process(text):\n            return 0.0\n\n        text_lower = text.lower()\n        match_count = sum(1 for kw in self.SUPPLIER_KEYWORDS if kw in text_lower)\n\n        # Higher score for more matches - ICAT documents should have many keyword hits\n        if match_count >= 5:\n            return 0.98\n        elif match_count >= 4:\n            return 0.95\n        elif match_count >= 3:\n            return 0.92\n        elif match_count >= 2:\n            return 0.88\n        return 0.80\n\n    def extract_invoice_number(self, text: str) -> str:\n        \"\"\"Extract invoice number from SHIPPER'S REF. NO. section or from invoice references.\"\"\"\n        patterns = [\n            r\"INV\\.\\s*(\\d+[A-Z]*)\",\n            r\"SHIPPER'S REF\\.?\\s*NO\\.?\\s*(?:.*?)INV\\.\\s*(\\d+[A-Z]*)\",\n            r\"INV\\.\\s+(\\d{5}[A-Z]?)\",\n            r\"INV\\.\\s*(\\d+[A-Z]*[A-Z])\",  # For formats like INV. 00823B\n        ]\n\n        # Find all invoice numbers and return the first one\n        for pattern in patterns:\n            matches = re.findall(pattern, text, re.IGNORECASE)\n            if matches:\n                return matches[0].strip()\n\n        # For packing lists, try to extract shipment number\n        shipment_match = re.search(r\"SHIPMENT:\\s*([\\w-]+)\", text, re.IGNORECASE)\n        if shipment_match:\n            return f\"SHIPMENT-{shipment_match.group(1)}\"\n\n        return \"UNKNOWN\"\n\n    def extract_all_invoice_numbers(self, text: str) -> List[str]:\n        \"\"\"Extract all invoice numbers from the document.\"\"\"\n        pattern = r\"INV\\.\\s*(\\d+[A-Z]*)\"\n        matches = re.findall(pattern, text, re.IGNORECASE)\n        \n        # If no invoice numbers found, try shipment number\n        if not matches:\n            shipment_match = re.search(r\"SHIPMENT:\\s*([\\w-]+)\", text, re.IGNORECASE)\n            if shipment_match:\n                return [f\"SHIPMENT-{shipment_match.group(1)}\"]\n        \n        return list(set(matches)) if matches else []\n\n    def extract_project_number(self, text: str) -> str:\n        \"\"\"Extract WK project number or shipment number.\"\"\"\n        patterns = [\n            r\"(WK\\d+-[A-Z0-9-]+)\",\n            r\"WK(\\d+[-\\w]+)\",\n            r\"SHIPMENT:\\s*([\\w-]+)\",\n        ]\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                if 'SHIPMENT' in pattern:\n                    return f\"SHIPMENT-{match.group(1)}\"\n                result = match.group(1) if match.group(1).startswith('WK') else f\"WK{match.group(1)}\"\n                return result\n        return \"UNKNOWN\"\n\n    def extract_manufacturer_name(self, text: str) -> str:\n        \"\"\"Return the manufacturer name.\"\"\"\n        return \"ICAT S.A. DE C.V.\"\n\n    def get_quantity_unit(self, part_number: str, description: str = \"\") -> str:\n        \"\"\"Determine the quantity unit based on part number prefix or description.\n\n        Footwear items (14xx, 15xx prefixes) use PRS (pairs)\n        Apparel items use DOZ (dozens)\n\n        Args:\n            part_number: The part/style number (base or concatenated)\n            description: Optional description text for additional detection\n\n        Returns:\n            'PRS' for footwear, 'DOZ' for apparel (matching TariffMill unit codes)\n        \"\"\"\n        # Check if part number starts with footwear prefixes (14 or 15)\n        part_upper = part_number.upper().strip()\n        if part_upper.startswith('14') or part_upper.startswith('15'):\n            return 'PRS'\n\n        # Also check description for footwear keywords\n        if description:\n            desc_lower = description.lower()\n            if any(kw in desc_lower for kw in ['footwear', 'boot', 'shoe', 'sandal']):\n                return 'PRS'\n\n        # Default to dozens for apparel\n        return 'DOZ'\n\n    def extract_base_style(self, concatenated_style: str) -> str:\n        \"\"\"Extract base style number from concatenated style-cut format.\n\n        Concatenated format: 13C33070HERR01VS1100WHTI\n        Base style format:   13C3-3070\n\n        Pattern breakdown:\n        - 2 digits (category): 13, 14, 15, 12, 10, 11, SK\n        - 1-2 letters (type): C, L, F, S, B, H, PA, TP, HD, etc.\n        - 1 digit (variant): 1, 2, 3, 4, etc.\n        - 4 digits (style number): 3070, 3301, 7254, etc.\n        - Remaining: cut/color/size variation (HERR01VS1100WHTI)\n\n        Examples:\n        - 13C33070HERR01VS1100WHTI -> 13C3-3070\n        - 14S13301TAFF01CN0000WHTI -> 14S1-3301\n        - 12L27254BEM001CC0000ROYI -> 12L2-7254\n        - SK01YLC -> SK01YLC (already short format, no change)\n        - 12F2-3165 -> 12F2-3165 (already has hyphen)\n        \"\"\"\n        style = concatenated_style.strip()\n\n        # If already has hyphen in the right place, return as-is\n        if '-' in style and len(style) <= 12:\n            return style\n\n        # If it's a short SK-style code, return as-is\n        if style.startswith('SK') and len(style) <= 8:\n            return style\n\n        # Try to extract base style from concatenated format\n        # Pattern: (2 digits)(1-2 letters)(1 digit)(4 chars)(rest)\n        # Examples: 13C3-3070, 14S1-3301, 12L2-7254, 13PA-6462, 12L1-54FC, 14P7-301G\n\n        # First try 2-letter type codes with alphanumeric style (BC, LS, etc.)\n        # e.g., 12BC10HSLAB01CC -> 12BC-10HS\n        match = re.match(\n            r'^(\\d{2})([A-Z]{2})[-]?(\\d{2}[A-Z]{2})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 12\n            type_code = match.group(2)   # BC\n            style_num = match.group(3)   # 10HS\n            return f\"{prefix}{type_code}-{style_num}\"\n\n        # Try 2-letter type codes with 4-digit style (PA, TP, HD, CV, FA, SV, EQ, HU, BZ, HY, HZ)\n        match = re.match(\n            r'^(\\d{2})([A-Z]{2})[-]?(\\d{4})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 13, 12, etc.\n            type_code = match.group(2)   # PA, TP, HD, etc.\n            style_num = match.group(3)   # 6462, 7158, etc.\n            return f\"{prefix}{type_code}-{style_num}\"\n\n        # Try 1-letter type codes with alphanumeric style (4 chars: digits + letters)\n        # e.g., 12L154FCEKC601WK -> 12L1-54FC, 14P7301GTAFF01VS -> 14P7-301G\n        match = re.match(\n            r'^(\\d{2})([A-Z])(\\d)(\\d{2}[A-Z]{2}|\\d{3}[A-Z])',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 12, 14, etc.\n            type_code = match.group(2)   # L, P, etc.\n            variant = match.group(3)     # 1, 7, etc.\n            style_num = match.group(4)   # 54FC, 301G, etc.\n            return f\"{prefix}{type_code}{variant}-{style_num}\"\n\n        # Then try 1-letter type codes with 4-digit style (C, L, F, S, B, H, M)\n        match = re.match(\n            r'^(\\d{2})([A-Z])(\\d)(\\d{4})',\n            style,\n            re.IGNORECASE\n        )\n        if match:\n            prefix = match.group(1)      # 13, 14, 12, etc.\n            type_code = match.group(2)   # C, L, F, S, etc.\n            variant = match.group(3)     # 1, 2, 3, etc.\n            style_num = match.group(4)   # 3070, 3301, etc.\n            return f\"{prefix}{type_code}{variant}-{style_num}\"\n\n        # If no match, return original\n        return style\n\n    def is_packing_list(self, text: str) -> bool:\n        \"\"\"Check if document is a packing list.\"\"\"\n        text_lower = text.lower()\n        # Look for packing list indicators\n        if 'packing list' in text_lower:\n            return True\n        # Look for structure typical of packing lists (has STYLE CUT UNITS DOZENS CASES columns)\n        if all(keyword in text_lower for keyword in ['style', 'cut', 'units', 'dozens', 'cases']):\n            return True\n        return False\n\n    def extract_line_items(self, text: str) -> List[Dict]:\n        \"\"\"Extract line items from document (invoice or packing list).\"\"\"\n        if self.is_packing_list(text):\n            return self._extract_packing_list_items(text)\n        else:\n            return self._extract_invoice_items(text)\n\n    def _extract_packing_list_items(self, text: str) -> List[Dict]:\n        \"\"\"Extract line items from packing list format.\n        \n        Packing list format:\n        STYLE CUT UNITS DOZENS CASES BUNDLES PRODUCER NAME ADDRESS\n        WEL19183C 4139 400.00 33.33 2 ICAT S.A DE C.V KM 12 1/2 CTRA...\n        \"\"\"\n        items = []\n        lines = text.split('\\n')\n        \n        # Extract document reference\n        doc_ref = self.extract_invoice_number(text)\n        project_ref = self.extract_project_number(text)\n        \n        # Pattern for packing list lines\n        # Style, Cut, Units (quantity), Dozens, Cases, Bundles, Producer info\n        packing_pattern = re.compile(\n            r'^([A-Z0-9][A-Z0-9-]{3,})\\s+'     # STYLE (like WEL19183C, F28-A03C, etc.)\n            r'(\\d+[-\\d]*)\\s+'                  # CUT (like 4139, 4224-26, etc.)\n            r'([\\d,]+\\.?\\d*)\\s+'               # UNITS (quantity like 400.00)\n            r'([\\d,]+\\.?\\d*)\\s+'               # DOZENS (like 33.33)\n            r'(\\d+)\\s+'                        # CASES (like 2)\n            r'(?:(\\d+)\\s+)?'                   # BUNDLES (optional, sometimes missing)\n            r'((?:ICAT|VIDALES)[^0-9]*)',      # PRODUCER (ICAT or VIDALES followed by address)\n            re.IGNORECASE\n        )\n\n        for line in lines:\n            line = line.strip()\n            if not line:\n                continue\n\n            # Skip header lines\n            if any(skip in line.upper() for skip in ['STYLE CUT UNITS', 'QUANTITY', 'PACKING LIST', 'CUSTOMER', 'CARRIER']):\n                continue\n                \n            # Skip total lines\n            if line.upper().startswith('TOTAL') or 'BOXES TOTAL' in line.upper():\n                continue\n\n            # Try to match packing list pattern\n            match = packing_pattern.match(line)\n            if match:\n                try:\n                    raw_style = match.group(1).strip()\n                    cut = match.group(2).strip()\n                    units = float(match.group(3).replace(',', ''))\n                    dozens = float(match.group(4).replace(',', ''))\n                    cases = int(match.group(5))\n                    bundles = int(match.group(6)) if match.group(6) else 0\n                    producer_info = match.group(7).strip()\n\n                    # Extract base style from concatenated format\n                    base_style = self.extract_base_style(raw_style)\n\n                    # Determine producer name\n                    if 'VIDALES' in producer_info.upper():\n                        producer = \""
    }
  ],
  "last_modified": "2025-12-27T01:08:14.051162"
}