"""
LaceyActFormTemplate - Auto-generated template for U.S. DEPARTMENT OF AGRICULTURE ANIMAL AND PLANT HEALTH INSPECTION SERVICE
Generated by TariffMill AI Template Builder
"""

import re
from typing import List, Dict
from .base_template import BaseTemplate


class LaceyActFormTemplate(BaseTemplate):
    """
    Template for U.S. DEPARTMENT OF AGRICULTURE ANIMAL AND PLANT HEALTH INSPECTION SERVICE invoices.

    Auto-generated patterns - review and adjust as needed.
    """

    name = "Lacey Act Form"
    description = "Invoice template for U.S. DEPARTMENT OF AGRICULTURE ANIMAL AND PLANT HEALTH INSPECTION SERVICE"
    client = "U.S. DEPARTMENT OF AGRICULTURE ANIMAL AND PLANT HEALTH INSPECTION SERVICE"
    version = "1.0.0"

    enabled = True

    extra_columns = ['htsus_number', 'entered_value', 'article_component', 'scientific_name', 'country_of_harvest', 'unit', 'percent_recycled']

    def can_process(self, text: str) -> bool:
        """Check if this template can process the given invoice."""
        return 'ppq form 505' in text.lower() and 'plant and plant product declaration form' in text.lower() and 'lacey act amendment' in text.lower() and 'omb approved 0579-0349' in text.lower() and 'paperwork reduction act of 1995' in text.lower()

    def get_confidence_score(self, text: str) -> float:
        """Return confidence score for template matching."""
        if not self.can_process(text):
            return 0.0

        score = 0.5
        # Add points for each indicator found
        indicators = ['PPQ FORM 505', 'Plant and Plant Product Declaration Form', 'Lacey Act Amendment', 'OMB APPROVED 0579-0349', 'Paperwork reduction Act of 1995']
        for indicator in indicators:
            if indicator.lower() in text.lower():
                score += 0.1

        return min(score, 1.0)

    def extract_invoice_number(self, text: str) -> str:
        """Extract invoice number."""
        patterns = [
            r'Invoice\\s*#?\\s*:?\\s*(\\w+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1).strip()

        return "UNKNOWN"

    def extract_project_number(self, text: str) -> str:
        """Extract project number."""
        patterns = [
            r'Project\\s*:?\\s*(\\w+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1).strip()

        return "UNKNOWN"

    def extract_line_items(self, text: str) -> List[Dict]:
        """Extract line items from invoice."""
        line_items = []
        seen_items = set()

        # Line item pattern - adjust as needed
        line_pattern = re.compile(
            r'(\d+\.\d+)\s+(\$?[\d,]+\.\d{2})\s+([^\s][^\n]+?)\s+([A-Z][a-z]+ [a-z]+)\s+([A-Z]{2,3})\s+([\d,]+\.?\d*)\s+([A-Z]{2,4})\s+(\d+)%',
            re.MULTILINE | re.IGNORECASE
        )

        for match in line_pattern.finditer(text):
            try:
                item = {
                        'htsus_number': match.group(1),
                        'entered_value': match.group(2),
                        'article_component': match.group(3),
                        'scientific_name': match.group(4),
                        'country_of_harvest': match.group(5),
                        'quantity': match.group(6),
                        'unit': match.group(7),
                        'percent_recycled': match.group(8),
                    }

                # Create deduplication key
                item_key = f"{item.get('part_number', '')}_{item.get('quantity', '')}"

                if item_key not in seen_items:
                    seen_items.add(item_key)
                    line_items.append(item)

            except (IndexError, AttributeError):
                continue

        return line_items
