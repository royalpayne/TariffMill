{
  "provider": "Anthropic",
  "model": "claude-sonnet-4-20250514",
  "conversation_history": [
    {
      "role": "user",
      "content": "The template code has an error that needs to be fixed.\n\nERROR TYPE: Template Error\nERROR MESSAGE: name '__file__' is not defined\n\nFULL TRACEBACK:\nTraceback (most recent call last):\n  File \"c:\\Users\\payne\\Tariffmill\\Tariffmill\\tariffmill.py\", line 12894, in _ai_test_template\n    exec(test_code, {'__name__': '__main__'})\n    ~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 23, in <module>\nNameError: name '__file__' is not defined. Did you mean: '__name__'?\n\n\nPlease fix this error in the template code. Return the complete corrected template code."
    },
    {
      "role": "assistant",
      "content": "The error occurs because `__file__` is not defined when the code is executed using `exec()`. I'll fix this by making the import path logic more robust and handling the case where `__file__` might not be available.\n\n```python\n\"\"\"\nSmart Universal Template - Uses SmartExtractor for automatic line item extraction\n\nThis template uses data shape recognition to extract line items from any invoice format.\nIt serves as a universal fallback that works without supplier-specific patterns.\n\nKey features:\n- Recognizes part codes, quantities, and prices by their data shapes\n- Verifies part numbers against the parts_master database\n- Works with inconsistent invoice layouts\n- Handles OCR errors in numbers and codes\n\"\"\"\n\nimport re\nfrom typing import List, Dict\nfrom .base_template import BaseTemplate\n\n# Import SmartExtractor\nimport sys\nfrom pathlib import Path\n\n# Add parent directory to path for imports - handle case where __file__ is not defined\ntry:\n    parent_dir = Path(__file__).parent.parent\n    if str(parent_dir) not in sys.path:\n        sys.path.insert(0, str(parent_dir))\nexcept NameError:\n    # __file__ not defined (e.g., when running with exec)\n    # Try to find the parent directory through sys.path\n    current_path = Path.cwd()\n    parent_dir = current_path.parent if 'Tariffmill' in current_path.name else current_path\n    if str(parent_dir) not in sys.path:\n        sys.path.insert(0, str(parent_dir))\n\ntry:\n    from smart_extractor import SmartExtractor, ExtractionResult\nexcept ImportError:\n    # Fallback for different import contexts\n    try:\n        from Tariffmill.smart_extractor import SmartExtractor, ExtractionResult\n    except ImportError:\n        SmartExtractor = None\n        ExtractionResult = None\n\n\nclass SmartUniversalTemplate(BaseTemplate):\n    \"\"\"\n    Universal template using SmartExtractor for automatic extraction.\n\n    This template can process any commercial invoice by recognizing\n    data patterns rather than fixed positions or supplier-specific formats.\n    \"\"\"\n\n    name = \"Smart Universal\"\n    description = \"Universal extractor using data shape recognition - works with any invoice format\"\n    client = \"Universal\"\n    version = \"1.0.0\"\n    enabled = True\n\n    extra_columns = ['unit_price', 'description', 'confidence']\n\n    # Known company patterns that indicate a commercial invoice\n    INVOICE_INDICATORS = [\n        r'\\binvoice\\b',\n        r'\\bcommercial\\s+invoice\\b',\n        r'\\bproforma\\b',\n        r'\\btax\\s+invoice\\b',\n        r'\\bsales\\s+invoice\\b',\n    ]\n\n    # Patterns that indicate this is NOT an invoice we should process\n    EXCLUSION_PATTERNS = [\n        r'\\bpacking\\s+list\\b(?!.*invoice)',  # Packing list without invoice\n        r'\\bshipping\\s+label\\b',\n        r'\\bdelivery\\s+note\\b',\n        r'\\bquotation\\b',\n        r'\\bpurchase\\s+order\\b',\n    ]\n\n    def __init__(self):\n        super().__init__()\n        self._extractor = None\n        self._last_result = None\n\n    @property\n    def extractor(self):\n        \"\"\"Lazy-load the SmartExtractor.\"\"\"\n        if self._extractor is None and SmartExtractor is not None:\n            self._extractor = SmartExtractor()\n        return self._extractor\n\n    def can_process(self, text: str) -> bool:\n        \"\"\"\n        Check if this template can process the invoice.\n\n        This template can process ANY invoice as a fallback, but returns\n        a lower confidence score so supplier-specific templates take priority.\n        \"\"\"\n        if SmartExtractor is None:\n            return False\n\n        text_lower = text.lower()\n\n        # Check for exclusion patterns\n        for pattern in self.EXCLUSION_PATTERNS:\n            if re.search(pattern, text_lower):\n                return False\n\n        # Check for invoice indicators\n        for pattern in self.INVOICE_INDICATORS:\n            if re.search(pattern, text_lower):\n                return True\n\n        # Also accept if we find typical invoice elements\n        has_prices = bool(re.search(r'\\$[\\d,]+\\.?\\d*|\\d+\\.\\d{2}\\b', text))\n        has_quantities = bool(re.search(r'\\b\\d+\\s*(?:pcs?|ea|units?|qty)\\b', text_lower))\n\n        return has_prices and has_quantities\n\n    def get_confidence_score(self, text: str) -> float:\n        \"\"\"\n        Return confidence score for template matching.\n\n        This template returns a moderate confidence (0.3-0.5) so that\n        supplier-specific templates with higher confidence take priority.\n        \"\"\"\n        if not self.can_process(text):\n            return 0.0\n\n        score = 0.3  # Base score - lower than specific templates\n\n        text_lower = text.lower()\n\n        # Increase score based on invoice markers\n        if re.search(r'\\bcommercial\\s+invoice\\b', text_lower):\n            score += 0.1\n        if re.search(r'\\binvoice\\s*(?:no\\.?|#|number)\\s*[:\\s]', text_lower):\n            score += 0.05\n        if re.search(r'\\bpo\\.?\\s*(?:no\\.?|#)\\s*[:\\s]*\\d+', text_lower):\n            score += 0.05\n\n        # Check if SmartExtractor can find items\n        if self.extractor:\n            try:\n                result = self.extractor.extract_from_text(text)\n                if len(result.line_items) > 0:\n                    score += 0.1\n                if len(result.line_items) >= 5:\n                    score += 0.05\n                # Higher score if database matches found\n                if self.extractor.db_matched_count > 0:\n                    score += 0.1\n            except Exception:\n                pass\n\n        return min(score, 0.6)  # Cap at 0.6 to let specific templates win\n\n    def extract_invoice_number(self, text: str) -> str:\n        \"\"\"Extract invoice number using SmartExtractor patterns.\"\"\"\n        if self.extractor and self._last_result:\n            if self._last_result.invoice_number:\n                return self._last_result.invoice_number\n\n        # Fallback patterns\n        patterns = [\n            r'Invoice\\s*(?:No\\.?|#|Number)[:\\s]*([A-Z0-9][\\w\\-/]+)',\n            r'INV[:\\s#]*([A-Z0-9][\\w\\-/]+)',\n            r'(?:Invoice|Inv)\\s+n\\.?\\s*[:\\s]*(\\d+)',\n            r'INVOICE\\s*(?:NO\\.?)?\\s*[:\\s]*([A-Z0-9][\\w\\-/]+)',\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).strip()\n\n        return \"UNKNOWN\"\n\n    def extract_project_number(self, text: str) -> str:\n        \"\"\"Extract PO/project number.\"\"\"\n        if self.extractor and self._last_result:\n            if self._last_result.po_numbers:\n                return self._last_result.po_numbers[0]\n\n        # Fallback patterns\n        patterns = [\n            r'P\\.?O\\.?\\s*(?:No\\.?|#|Number)?[:\\s]*(\\d{6,})',\n            r'Purchase\\s*Order[:\\s]*(\\d+)',\n            r'Order\\s*(?:No\\.?|#)?[:\\s]*(\\d+)',\n            r'\\b(400\\d{5})\\b',  # Sigma PO format\n        ]\n\n        for pattern in patterns:\n            match = re.search(pattern, text, re.IGNORECASE)\n            if match:\n                return match.group(1).strip()\n\n        return \"UNKNOWN\"\n\n    def extract_manufacturer_name(self, text: str) -> str:\n        \"\"\"Extract manufacturer/supplier name.\"\"\"\n        if self.extractor and self._last_result:\n            if self._last_result.supplier_name:\n                return self._last_result.supplier_name\n\n        # Try to find company name in header\n        lines = text.split('\\n')[:15]\n        for line in lines:\n            line = line.strip()\n            if re.search(r'\\b(LTD\\.?|LLC|INC\\.?|CORP\\.?|PVT\\.?|CO\\.)\\b', line, re.IGNORECASE):\n                if 5 < len(line) < 80:\n                    return line\n\n        return \"\"\n\n    def extract_line_items(self, text: str) -> List[Dict]:\n        \"\"\"\n        Extract line items using SmartExtractor.\n\n        This is the key method that leverages the SmartExtractor's\n        data shape recognition capabilities.\n        \"\"\"\n        if not self.extractor:\n            return []\n\n        try:\n            # Use SmartExtractor\n            self._last_result = self.extractor.extract_from_text(text)\n\n            # Convert LineItem objects to dicts for template compatibility\n            items = []\n            for item in self._last_result.line_items:\n                items.append({\n                    'part_number': item.part_number,\n                    'quantity': item.quantity,\n                    'total_price': item.total_price,\n                    'unit_price': item.unit_price,\n                    'description': item.description,\n                    'confidence': f\"{item.confidence:.0%}\",\n                })\n\n            return items\n\n        except Exception as e:\n            print(f\"SmartExtractor error: {e}\")\n            return []\n\n    def post_process_items(self, items: List[Dict]) -> List[Dict]:\n        \"\"\"Post-process items - deduplicate and validate.\"\"\"\n        if not items:\n            return items\n\n        # Deduplicate based on part_number + quantity + total_price\n        seen = set()\n        unique_items = []\n\n        for item in items:\n            key = f\"{item['part_number']}_{item['quantity']}_{item['total_price']}\"\n            if key not in seen:\n                seen.add(key)\n                unique_items.append(item)\n\n        return unique_items\n\n    def is_packing_list(self, text: str) -> bool:\n        \"\"\"Check if document is only a packing list.\"\"\"\n        text_lower = text.lower()\n        if 'packing list' in text_lower:\n            # If it also contains invoice, process it\n            if 'invoice' in text_lower:\n                return False\n            return True\n        return False\n```\n\n**Changes made:**\n\nI wrapped the `Path(__file__)` usage in a try-except block to handle the case where `__file__` is not defined (which happens when code is executed using `exec()`). The fix:\n\n1. **Added try-except around `__file__` usage**: When `__file__` is not defined, it catches the `NameError` and falls back to using `Path.cwd()` to determine the current working directory.\n\n2. **Graceful fallback**: If the current directory contains 'Tariffmill', it uses the parent directory; otherwise, it uses the current directory for the import path.\n\nThis ensures the template will work both in normal execution contexts (where `__file__` is available) and in testing contexts where code is executed using `exec()`."
    }
  ],
  "last_modified": "2025-12-27T09:46:18.842262"
}