"""
UsCustomsppqPlantProtectionAndQuarantineTemplate - Auto-generated template for U.S. Customs/PPQ (Plant Protection and Quarantine)
Generated by TariffMill AI Template Builder
"""

import re
from typing import List, Dict
from .base_template import BaseTemplate


class UsCustomsppqPlantProtectionAndQuarantineTemplate(BaseTemplate):
    """
    Template for U.S. Customs/PPQ (Plant Protection and Quarantine) invoices.

    Auto-generated patterns - review and adjust as needed.
    """

    name = "Us Customsppq Plant Protection And Quarantine"
    description = "Invoice template for U.S. Customs/PPQ (Plant Protection and Quarantine)"
    client = "U.S. Customs/PPQ (Plant Protection and Quarantine)"
    version = "1.0.0"

    enabled = True

    extra_columns = ['htsus_number', 'entered_value', 'country_of_harvest', 'genus', 'species']

    def can_process(self, text: str) -> bool:
        """Check if this template can process the given invoice."""
        return 'version 08-15-2011-0856' in text.lower() and 'ppq 505' in text.lower() and 'estimated date of arrival' in text.lower() and 'entry number' in text.lower() and 'htsus number' in text.lower()

    def get_confidence_score(self, text: str) -> float:
        """Return confidence score for template matching."""
        if not self.can_process(text):
            return 0.0

        score = 0.5
        # Add points for each indicator found
        indicators = ['Version 08-15-2011-0856', 'PPQ 505', 'Estimated Date of Arrival', 'Entry Number', 'HTSUS Number']
        for indicator in indicators:
            if indicator.lower() in text.lower():
                score += 0.1

        return min(score, 1.0)

    def extract_invoice_number(self, text: str) -> str:
        """Extract invoice number."""
        patterns = [
            r'Invoice\\s*#?\\s*:?\\s*(\\w+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1).strip()

        return "UNKNOWN"

    def extract_project_number(self, text: str) -> str:
        """Extract project number."""
        patterns = [
            r'Project\\s*:?\\s*(\\w+)',
        ]

        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return match.group(1).strip()

        return "UNKNOWN"

    def extract_line_items(self, text: str) -> List[Dict]:
        """Extract line items from invoice."""
        line_items = []
        seen_items = set()

        # Line item pattern - adjust as needed
        line_pattern = re.compile(
            r'^(\d{10})\s+(\d+(?:\.\d{2})?)\s+(\w+(?:\s+\w+)*)\s+(\w+)\s+(\w+)',
            re.MULTILINE | re.IGNORECASE
        )

        for match in line_pattern.finditer(text):
            try:
                item = {
                        'htsus_number': match.group(1),
                        'entered_value': match.group(2),
                        'country_of_harvest': match.group(3),
                        'genus': match.group(4),
                        'species': match.group(5),
                    }

                # Create deduplication key
                item_key = f"{item.get('part_number', '')}_{item.get('quantity', '')}"

                if item_key not in seen_items:
                    seen_items.add(item_key)
                    line_items.append(item)

            except (IndexError, AttributeError):
                continue

        return line_items
